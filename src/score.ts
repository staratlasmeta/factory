import { AnchorProvider, BN, Idl, Program, web3 } from '@coral-xyz/anchor';
import type { AnchorTypes } from './anchor/types';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { SystemProgram } from '@solana/web3.js';
import { FactoryReturn, getPlayerFactionPDA } from '.';
import { baseIdl } from './util/scoreIdl';
import { scoreLogBaseIdl } from './util/scoreLogIdl';
import { getTokenAccount } from './util';
import * as SCORE_TYPES from './util/scoreIdl';

export type SCORE_PROGRAM = SCORE_TYPES.Score;
export type ScoreTypes = AnchorTypes<SCORE_PROGRAM>;
type Account = ScoreTypes['Accounts'];

export type ShipStakingInfo = Account['ShipStaking'];
export type ScoreVarsShipInfo = Account['ScoreVarsShip'];
export type ScoreVarsInfo = Account['ScoreVars'];

/**
 * Returns the base IDL for the SCORE program following as generated by Anchor with provided program ID appended to metadata.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - The base IDL object
 */
export function getScoreIDL(programId: web3.PublicKey): unknown {
  const _tmp = baseIdl;
  _tmp['metadata']['address'] = programId.toBase58();
  return _tmp;
}

/**
 * Returns the public key and bump seed for the SCORE variables account.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Public key, bump seed]
 */
export function getScoreVarsAccount(
  programId: web3.PublicKey,
): [web3.PublicKey, number] {
  return web3.PublicKey.findProgramAddressSync(
    [Buffer.from('SCOREVARS')],
    programId,
  );
}

/**
 * Returns the public key and bump seed for the SCORE variables ship account associated with the provided ship mint.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 * @returns - [Ship account public key, bump seed]
 */
export function getScoreVarsShipAccount(
  programId: web3.PublicKey,
  shipMint: web3.PublicKey,
): [web3.PublicKey, number] {
  return web3.PublicKey.findProgramAddressSync(
    [Buffer.from('SCOREVARS_SHIP'), shipMint.toBuffer()],
    programId,
  );
}

/**
 * Returns the public key and bump seed for a user's SCORE escrow account.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 * @param resourceMint - Mint address for the desired R4 resource
 * @param playerPublicKey - Player's public key
 * @returns - [Escrow account public key, bump seed]
 */
export function getScoreEscrowAccount(
  programId: web3.PublicKey,
  shipMint: web3.PublicKey,
  resourceMint: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
): [web3.PublicKey, number] {
  const seeds = [
    Buffer.from('SCORE_ESCROW'),
    playerPublicKey.toBuffer(),
    shipMint.toBuffer(),
  ];
  if (resourceMint !== null) {
    seeds.push(resourceMint.toBuffer());
  }
  return web3.PublicKey.findProgramAddressSync(seeds, programId);
}

/**
 * Returns the SCORE escrow authority account
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 * @param playerPublicKey - Player's public key
 * @returns - [Authority account public key, bump seed]
 */
export function getScoreEscrowAuthAccount(
  programId: web3.PublicKey,
  shipMint: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
): [web3.PublicKey, number] {
  return web3.PublicKey.findProgramAddressSync(
    [
      Buffer.from('SCORE_ESCROW_AUTHORITY'),
      playerPublicKey.toBuffer(),
      shipMint.toBuffer(),
    ],
    programId,
  );
}

/**
 * Returns a user's ship staking account
 *
 * @param programId - Deployed program ID for the SCORE program
 * @param assetMint - Mint address for the desired resource
 * @param playerPublicKey - Player's public key
 * @returns - [Staking account public key, bump seed]
 */
export function getShipStakingAccount(
  programId: web3.PublicKey,
  assetMint: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
): [web3.PublicKey, number] {
  return web3.PublicKey.findProgramAddressSync(
    [
      Buffer.from('SCORE_INFO'),
      playerPublicKey.toBuffer(),
      assetMint.toBuffer(),
    ],
    programId,
  );
}

/**
 * Returns the current SCORE variables' info.
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 */
export async function getScoreVarsInfo(
  connection: web3.Connection,
  programId: web3.PublicKey,
): Promise<ScoreVarsInfo> {
  const provider = new AnchorProvider(connection, null, null);
  const idl = getScoreIDL(programId);
  const program = new Program(<Idl>idl, programId, provider);

  const [scoreVarsAccount] = getScoreVarsAccount(programId);
  const obj = await program.account.scoreVars.fetch(scoreVarsAccount);
  return <ScoreVarsInfo>obj;
}

/**
 * Returns the current ship staking account info for a player and ship mint.
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - ship mint address
 * @param playerPublicKey - Player's public key
 */
export async function getShipStakingAccountInfo(
  connection: web3.Connection,
  programId: web3.PublicKey,
  shipMint: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
): Promise<ShipStakingInfo> {
  const provider = new AnchorProvider(connection, null, null);
  const idl = getScoreIDL(programId);
  const program = new Program(<Idl>idl, programId, provider);

  const [shipStakingAccount] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const obj = await program.account.shipStaking.fetch(shipStakingAccount);
  return <ShipStakingInfo>obj;
}

/**
 * Returns decoded event
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @param event - Event to decode
 */
export async function decodeEvent(
  connection: web3.Connection,
  programId: web3.PublicKey,
  event: string,
): Promise<any> {
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>scoreLogBaseIdl, programId, provider);
  return program.coder.events.decode(event);
}

/**
 * Returns the current SCORE variables info for a designated ship mint.
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @param shipMint - Ship mint address
 */
export async function getScoreVarsShipInfo(
  connection: web3.Connection,
  programId: web3.PublicKey,
  shipMint: web3.PublicKey,
): Promise<ScoreVarsShipInfo> {
  const provider = new AnchorProvider(connection, null, null);
  const idl = getScoreIDL(programId);
  const program = new Program(<Idl>idl, programId, provider);

  const [scoreVarsShipAccount] = getScoreVarsShipAccount(programId, shipMint,
  );
  const obj = await program.account.scoreVarsShip.fetch(scoreVarsShipAccount);
  return <ScoreVarsShipInfo>obj;
}

/**
 * Returns the public key and bump seed for the SCORE treasury token account.
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Treasury's Public key, bump seed]
 */
export function getScoreTreasuryTokenAccount(
  programId: web3.PublicKey,
): [web3.PublicKey, number] {
  return web3.PublicKey.findProgramAddressSync(
    [Buffer.from('SCORE_TREASURY')],
    programId,
  );
}

/**
 * Returns the treasury authority account
 *
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Authority account public key, bump seed]
 */
export function getScoreTreasuryAuthAccount(
  programId: web3.PublicKey,
): [web3.PublicKey, number] {
  return web3.PublicKey.findProgramAddressSync(
    [Buffer.from('SCORE_TREASURY_AUTHORITY')],
    programId,
  );
}

/**
 * Returns a list registered ships
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Ship Staking Account Infos]
 */
export async function getAllRegisteredShips(
  connection: web3.Connection,
  programId: web3.PublicKey,
): Promise<ScoreVarsShipInfo[]> {
  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const _shipsRegistered = await program.account.scoreVarsShip.all();
  const shipsRegistered = [];
  for (const ship of _shipsRegistered) {
    shipsRegistered.push(<ScoreVarsShipInfo>ship.account);
  }
  return shipsRegistered;
}

/**
 * Returns a list of all fleets
 *
 * @param connection - web3.Connection object
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Ship Staking Account Infos]
 */
export async function getAllFleets(
  connection: web3.Connection,
  programId: web3.PublicKey,
): Promise<ShipStakingInfo[]> {
  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const _shipStakingAccounts = await program.account.shipStaking.all();
  const shipStakingAccounts = [];
  for (const stakingAccount of _shipStakingAccounts) {
    shipStakingAccounts.push(<ShipStakingInfo>stakingAccount.account);
  }
  return shipStakingAccounts;
}

/**
 * Returns a list of player deployed fleets to the SCORE program
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param programId - Deployed program ID for the SCORE program
 * @returns - [Ship Staking Account Infos]
 */
export async function getAllFleetsForUserPublicKey(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<ShipStakingInfo[]> {
  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const shipsRegistered = await program.account.scoreVarsShip.all();

  const playerShipStakingAccounts = [];
  for (const ship of shipsRegistered) {
    const [playerShipStakingAccount] = getShipStakingAccount(
      programId,
      ship.account.shipMint as web3.PublicKey,
      playerPublicKey,
    );
    playerShipStakingAccounts.push(playerShipStakingAccount);
  }

  const _playerFleets = await program.account.shipStaking.fetchMultiple(
    playerShipStakingAccounts,
  );
  const playerFleets: ShipStakingInfo[] = _playerFleets
    .filter((fleet) => fleet !== null)
    .map((fleet) => <ShipStakingInfo>fleet);

  return playerFleets;
}

/**
 * Initializes Score variables account and creates ATLAS treasury token account
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - Desired authority public key
 * @param atlasMint - ATLAS mint address
 * @param fuelMint - Fuel mint address
 * @param foodMint - Food mint address
 * @param armsMint - Arms mint address
 * @param toolkitMint - Toolkit mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createScoreVarsInitializeInstruction(
  connection: web3.Connection,
  updateAuthorityAccount: web3.PublicKey,
  atlasMint: web3.PublicKey,
  fuelMint: web3.PublicKey,
  foodMint: web3.PublicKey,
  armsMint: web3.PublicKey,
  toolkitMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const [treasuryTokenAccount, treasuryBump] =
    getScoreTreasuryTokenAccount(programId);
  const [treasuryAuthorityAccount, treasuryAuthBump] =
    getScoreTreasuryAuthAccount(programId);
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const ix = await program.instruction.processInitialize(
    scoreVarsBump,
    treasuryBump,
    treasuryAuthBump,
    {
      accounts: {
        updateAuthorityAccount: updateAuthorityAccount,
        scoreVarsAccount: scoreVarsAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
        rent: web3.SYSVAR_RENT_PUBKEY,
        treasuryTokenAccount: treasuryTokenAccount,
        treasuryAuthorityAccount: treasuryAuthorityAccount,
        atlasMint: atlasMint,
        fuelMint: fuelMint,
        foodMint: foodMint,
        armsMint: armsMint,
        toolkitMint: toolkitMint,
      },
      signers: [],
    },
  );
  return ix;
}

/**
 * Initiates Score variables account for a provided ship mint.
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param fuelMaxReserve - Max fuel in token units
 * @param foodMaxReserve - Max food in token units
 * @param armsMaxReserve - Max arms in token units
 * @param toolkitMaxReserve - Max toolkits in token units
 * @param millisecondsToBurnFuel - the amount of milliseconds to burn one fuel token
 * @param millisecondsToBurnFood - the amount of milliseconds to burn one food token
 * @param millisecondsToBurnArms - the amount of milliseconds to burn one arms token
 * @param millisecondsToBurnToolkit - the amount of milliseconds to burn one toolkit token
 * @param rewardRatePerSecond - Atlas rewarded per second
 * @param programId - Deployed Score program ID
 */
export async function createRegisterShipInstruction(
  connection: web3.Connection,
  updateAuthorityAccount: web3.PublicKey,
  shipMint: web3.PublicKey,
  fuelMaxReserve: number,
  foodMaxReserve: number,
  armsMaxReserve: number,
  toolkitMaxReserve: number,
  millisecondsToBurnFuel: number,
  millisecondsToBurnFood: number,
  millisecondsToBurnArms: number,
  millisecondsToBurnToolkit: number,
  rewardRatePerSecond: number,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const ix = await program.instruction.processRegisterShip(
    scoreVarsBump,
    scoreVarsShipBump,
    new BN(rewardRatePerSecond),
    fuelMaxReserve,
    foodMaxReserve,
    armsMaxReserve,
    toolkitMaxReserve,
    millisecondsToBurnFuel,
    millisecondsToBurnFood,
    millisecondsToBurnArms,
    millisecondsToBurnToolkit,
    {
      accounts: {
        updateAuthorityAccount: updateAuthorityAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        shipMint: shipMint,
        systemProgram: SystemProgram.programId,
      },
      signers: [],
    },
  );
  return ix;
}

/**
 * Deregister a ship that was already registered (Admin only)
 * Only to be called in the event of an invalid register
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param programId - Deployed Score program ID
 */
export async function createDeregisterShipInstruction(
  connection: web3.Connection,
  updateAuthorityAccount: web3.PublicKey,
  shipMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const ix = await program.instruction.processDeregisterShip(
    scoreVarsBump,
    scoreVarsShipBump,
    {
      accounts: {
        updateAuthorityAccount: updateAuthorityAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        shipMint: shipMint,
      },
      signers: [],
    },
  );
  return ix;
}

/**
 * Update a ship's reward rate (Admin only)
 *
 * @param connection - web3.Connection object
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param newRewardRatePerSecond - New Atlas rewards per second in base units
 * @param programId - Deployed Score program ID
 */
export async function createUpdateRewardRateInstruction(
  connection: web3.Connection,
  updateAuthorityAccount: web3.PublicKey,
  shipMint: web3.PublicKey,
  newRewardRatePerSecond: number,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const ix = await program.instruction.processUpdateRewardRate(
    scoreVarsBump,
    scoreVarsShipBump,
    new BN(newRewardRatePerSecond),
    {
      accounts: {
        updateAuthorityAccount: updateAuthorityAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        shipMint: shipMint,
      },
      signers: [],
    },
  );
  return ix;
}

/**
 * Provides a transaction instruction which can be used to deposit a specified quantity of ships to a player's ship staking account.
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipQuantity - Quantity to deposit as u64
 * @param shipMint - Ship mint address
 * @param shipTokenAccount - Token account for the ship resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createInitialDepositInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  shipQuantity: number,
  shipMint: web3.PublicKey,
  shipTokenAccount: web3.PublicKey,
  programId: web3.PublicKey,
  factionEnlistmentProgramId: web3.PublicKey = new web3.PublicKey(
    'FACTNmq2FhA2QNTnGM2aWJH3i7zT3cND5CgvjYTjyVYe',
  ),
): Promise<web3.TransactionInstruction> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [shipEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    null,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [playerFactionPDA] = getPlayerFactionPDA(
    playerPublicKey,
    factionEnlistmentProgramId,
  );

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processInitialDeposit(
    stakingBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    new BN(shipQuantity),
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        playerFactionAccount: playerFactionPDA,
        escrowAuthority: escrowAuthority,
        systemProgram: web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        rent: web3.SYSVAR_RENT_PUBKEY,
        shipMint: shipMint,
        shipTokenAccountSource: shipTokenAccount,
        shipTokenAccountEscrow: shipEscrow,
      },
    },
  );
  return ix;
}

/**
 * Provides a transaction instruction which can be used to deposit a specified quantity of ships to an already deployed player's ship staking account.
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipQuantity - Quantity to deposit as u64
 * @param shipMint - Ship mint address
 * @param shipTokenAccount - Token account for the ship resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createPartialDepositInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  shipQuantity: number,
  shipMint: web3.PublicKey,
  shipTokenAccount: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [shipEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    null,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processPartialDeposit(
    stakingBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    new BN(shipQuantity),
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        escrowAuthority: escrowAuthority,
        systemProgram: web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        shipMint: shipMint,
        shipTokenAccountSource: shipTokenAccount,
        shipTokenAccountEscrow: shipEscrow,
      },
    },
  );
  return ix;
}

/**
 * Provides a transaction instruction which can be used to transfer arms resources to a player's arms escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param armsQuantity - Arms resource quantity as u64
 * @param shipMint - Ship mint address
 * @param armsMint - Arms resource mint address
 * @param armsTokenAccount - Token account for the arms resources being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createRearmInstruction(
  connection: web3.Connection,
  tokenOwnerPublickey: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
  armsQuantity: number,
  shipMint: web3.PublicKey,
  armsMint: web3.PublicKey,
  armsTokenAccount: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [armsEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    armsMint,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processRearm(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    new BN(armsQuantity),
    {
      accounts: {
        tokenOwnerAccount: tokenOwnerPublickey,
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        escrowAuthority: escrowAuthority,
        systemProgram: web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        rent: web3.SYSVAR_RENT_PUBKEY,
        shipMint: shipMint,
        armsMint: armsMint,
        armsTokenAccountSource: armsTokenAccount,
        armsTokenAccountEscrow: armsEscrow,
      },
    },
  );

  return ix;
}

/**
 * Provides a transaction instruction which can be used to transfer food resources to a player's food escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param foodQuantity - Food resource quantity as u64
 * @param shipMint - Ship mint address
 * @param foodMint - Food resource mint address
 * @param foodTokenAccount - Token account for the food resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createRefeedInstruction(
  connection: web3.Connection,
  tokenOwnerPublickey: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
  foodQuantity: number,
  shipMint: web3.PublicKey,
  foodMint: web3.PublicKey,
  foodTokenAccount: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [foodEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    foodMint,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processRefeed(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    new BN(foodQuantity),
    {
      accounts: {
        tokenOwnerAccount: tokenOwnerPublickey,
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        escrowAuthority: escrowAuthority,
        systemProgram: web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        rent: web3.SYSVAR_RENT_PUBKEY,
        shipMint: shipMint,
        foodMint: foodMint,
        foodTokenAccountSource: foodTokenAccount,
        foodTokenAccountEscrow: foodEscrow,
      },
    },
  );

  return ix;
}

/**
 * Provides a transaction instruction which can be used to transfer fuel resources to a player's fuel escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param fuelQuantity - Fuel resource quantity as u64
 * @param shipMint - Ship mint address
 * @param fuelMint - Fuel resource mint address
 * @param fuelTokenAccount - Token account for the fuel resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createRefuelInstruction(
  connection: web3.Connection,
  tokenOwnerPublickey: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
  fuelQuantity: number,
  shipMint: web3.PublicKey,
  fuelMint: web3.PublicKey,
  fuelTokenAccount: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [fuelEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    fuelMint,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processRefuel(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    new BN(fuelQuantity),
    {
      accounts: {
        tokenOwnerAccount: tokenOwnerPublickey,
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        escrowAuthority: escrowAuthority,
        systemProgram: web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        rent: web3.SYSVAR_RENT_PUBKEY,
        shipMint: shipMint,
        fuelMint: fuelMint,
        fuelTokenAccountSource: fuelTokenAccount,
        fuelTokenAccountEscrow: fuelEscrow,
      },
    },
  );

  return ix;
}

/**
 * Provides a transaction instruction which can be used to transfer toolkit resources to a player's toolkit escrow account.
 *
 * @param connection - web3.Connection object
 * @param tokenOwnerPublickey - Resource Token Account Owner
 * @param playerPublicKey - Player's public key
 * @param toolkitQuantity - Toolkit resource quantity as u64
 * @param shipMint - Ship mint address
 * @param toolkitMint - Toolkit resource mint address
 * @param toolkitTokenAccount - Token account for the toolkit resource being deposited
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createRepairInstruction(
  connection: web3.Connection,
  tokenOwnerPublickey: web3.PublicKey,
  playerPublicKey: web3.PublicKey,
  toolkitQuantity: number,
  shipMint: web3.PublicKey,
  toolkitMint: web3.PublicKey,
  toolkitTokenAccount: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processRepair(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    new BN(toolkitQuantity),
    {
      accounts: {
        tokenOwnerAccount: tokenOwnerPublickey,
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        systemProgram: web3.SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        rent: web3.SYSVAR_RENT_PUBKEY,
        shipMint: shipMint,
        toolkitMint: toolkitMint,
        toolkitTokenAccountSource: toolkitTokenAccount,
      },
    },
  );

  return ix;
}

/**
 * Returns an instruction that can be used to update the amount of ATLAS in a player's pending rewards and update staked time paid
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param updateAuthorityAccount - valid authority public key
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createSettleInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  updateAuthorityAccount: web3.PublicKey,
  shipMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processSettle(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    {
      accounts: {
        playerAccount: playerPublicKey,
        updateAuthorityAccount: updateAuthorityAccount,
        shipStakingAccount: shipStakingAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        scoreVarsAccount: scoreVarsAccount,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        shipMint: shipMint,
      },
    },
  );
  return ix;
}

/**
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param atlasMint - Atlas mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createHarvestInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  atlasMint: web3.PublicKey,
  shipMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<FactoryReturn> {
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [treasuryTokenAccount, treasuryBump] =
    getScoreTreasuryTokenAccount(programId);
  const [treasuryAuthorityAccount, treasuryAuthBump] =
    getScoreTreasuryAuthAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const ixSet: FactoryReturn = {
    signers: [],
    instructions: [],
  };

  // Fetch user's atlas token account
  let playerAtlasTokenAccount: web3.PublicKey;
  const response = await getTokenAccount(
    connection,
    playerPublicKey,
    atlasMint,
  );
  const tokenAccount: web3.PublicKey | web3.Keypair = response.tokenAccount;
  if ('createInstruction' in response) {
    ixSet.instructions.push(...response.createInstruction);
  }

  if (tokenAccount instanceof web3.Keypair) {
    playerAtlasTokenAccount = tokenAccount.publicKey;
    ixSet.signers.push(tokenAccount);
  } else {
    playerAtlasTokenAccount = tokenAccount;
  }

  const ix = await program.instruction.processHarvest(
    stakingBump,
    scoreVarsShipBump,
    treasuryBump,
    treasuryAuthBump,
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        playerAtlasTokenAccount: playerAtlasTokenAccount,
        treasuryTokenAccount: treasuryTokenAccount,
        treasuryAuthorityAccount: treasuryAuthorityAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        shipMint: shipMint,
      },
    },
  );
  ixSet.instructions.push(ix);
  return ixSet;
}

/**
 * Withdraw Fuel from Escrow - required before withdrawShip
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param fuelMint - Fuel resource mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createWithdrawFuelInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  fuelMint: web3.PublicKey,
  shipMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<FactoryReturn> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [fuelEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    fuelMint,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const ixSet: FactoryReturn = {
    signers: [],
    instructions: [],
  };

  // Fetch user's fuel token account
  let fuelTokenAccount: web3.PublicKey;
  const response = await getTokenAccount(connection, playerPublicKey, fuelMint);
  const tokenAccount: web3.PublicKey | web3.Keypair = response.tokenAccount;
  if ('createInstruction' in response) {
    ixSet.instructions.push(...response.createInstruction);
  }

  if (tokenAccount instanceof web3.Keypair) {
    fuelTokenAccount = tokenAccount.publicKey;
    ixSet.signers.push(tokenAccount);
  } else {
    fuelTokenAccount = tokenAccount;
  }

  const ix = await program.instruction.processWithdrawFuel(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        fuelTokenAccountEscrow: fuelEscrow,
        fuelTokenAccountReturn: fuelTokenAccount,
        fuelMint: fuelMint,
        escrowAuthority: escrowAuthority,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        shipMint: shipMint,
      },
    },
  );
  ixSet.instructions.push(ix);
  return ixSet;
}

/**
 * Withdraw Food from Escrow - required before withdrawShip
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param foodMint - Food resource mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createWithdrawFoodInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  foodMint: web3.PublicKey,
  shipMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<FactoryReturn> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [foodEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    foodMint,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const ixSet: FactoryReturn = {
    signers: [],
    instructions: [],
  };

  // Fetch user's food token account
  let foodTokenAccount: web3.PublicKey;
  const response = await getTokenAccount(connection, playerPublicKey, foodMint);
  const tokenAccount: web3.PublicKey | web3.Keypair = response.tokenAccount;
  if ('createInstruction' in response) {
    ixSet.instructions.push(...response.createInstruction);
  }

  if (tokenAccount instanceof web3.Keypair) {
    foodTokenAccount = tokenAccount.publicKey;
    ixSet.signers.push(tokenAccount);
  } else {
    foodTokenAccount = tokenAccount;
  }

  const ix = await program.instruction.processWithdrawFood(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        foodTokenAccountEscrow: foodEscrow,
        foodTokenAccountReturn: foodTokenAccount,
        foodMint: foodMint,
        escrowAuthority: escrowAuthority,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        shipMint: shipMint,
      },
    },
  );
  ixSet.instructions.push(ix);
  return ixSet;
}

/**
 * Withdraw Arms from Escrow - required before withdrawShip
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param armsMint - Arms resource mint address
 * @param shipMint - Ship mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createWithdrawArmsInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  armsMint: web3.PublicKey,
  shipMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<FactoryReturn> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [armsEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    armsMint,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  const ixSet: FactoryReturn = {
    signers: [],
    instructions: [],
  };

  // Fetch user's arms token account
  let armsTokenAccount: web3.PublicKey;
  const response = await getTokenAccount(connection, playerPublicKey, armsMint);
  const tokenAccount: web3.PublicKey | web3.Keypair = response.tokenAccount;
  if ('createInstruction' in response) {
    ixSet.instructions.push(...response.createInstruction);
  }

  if (tokenAccount instanceof web3.Keypair) {
    armsTokenAccount = tokenAccount.publicKey;
    ixSet.signers.push(tokenAccount);
  } else {
    armsTokenAccount = tokenAccount;
  }

  const ix = await program.instruction.processWithdrawArms(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        armsTokenAccountEscrow: armsEscrow,
        armsTokenAccountReturn: armsTokenAccount,
        armsMint: armsMint,
        escrowAuthority: escrowAuthority,
        tokenProgram: TOKEN_PROGRAM_ID,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        shipMint: shipMint,
      },
    },
  );
  ixSet.instructions.push(ix);
  return ixSet;
}

/**
 * Withdraw Ships from Escrow
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipMint - Ship mint address
 * @param atlasMint - ATLAS token mint
 * @param toolkitMint - Toolkit resource mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function createWithdrawShipsInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  shipMint: web3.PublicKey,
  atlasMint: web3.PublicKey,
  toolkitMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<FactoryReturn> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [shipEscrow, escrowBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    null,
    playerPublicKey,
  );
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [scoreVarsShipAccount, scoreVarsShipBump] = getScoreVarsShipAccount(
    programId,
    shipMint,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);
  const [treasuryTokenAccount, treasuryBump] =
    getScoreTreasuryTokenAccount(programId);
  const [treasuryAuthorityAccount, treasuryAuthBump] =
    getScoreTreasuryAuthAccount(programId);

  const ixSet: FactoryReturn = {
    signers: [],
    instructions: [],
  };

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);

  // Get user's Atlas token account
  let playerAtlasTokenAccount: web3.PublicKey;
  const atlasResponse = await getTokenAccount(
    connection,
    playerPublicKey,
    atlasMint,
  );
  const potentialAtlasTokenAccount: web3.PublicKey | web3.Keypair =
    atlasResponse.tokenAccount;
  if ('createInstruction' in atlasResponse) {
    ixSet.instructions.push(...atlasResponse.createInstruction);
  }

  if (potentialAtlasTokenAccount instanceof web3.Keypair) {
    playerAtlasTokenAccount = potentialAtlasTokenAccount.publicKey;
    ixSet.signers.push(potentialAtlasTokenAccount);
  } else {
    playerAtlasTokenAccount = potentialAtlasTokenAccount;
  }

  // Get user's ship token account
  let shipTokenAccount: web3.PublicKey;
  const shipResponse = await getTokenAccount(
    connection,
    playerPublicKey,
    shipMint,
  );
  const potentialShipTokenAccount: web3.PublicKey | web3.Keypair =
    shipResponse.tokenAccount;
  if ('createInstruction' in shipResponse) {
    ixSet.instructions.push(...shipResponse.createInstruction);
  }

  if (potentialShipTokenAccount instanceof web3.Keypair) {
    shipTokenAccount = potentialShipTokenAccount.publicKey;
    ixSet.signers.push(potentialShipTokenAccount);
  } else {
    shipTokenAccount = potentialShipTokenAccount;
  }

  // Get user's toolkit token account
  let toolkitTokenAccount: web3.PublicKey;
  const response = await getTokenAccount(
    connection,
    playerPublicKey,
    toolkitMint,
  );
  const potentialToolkitTokenAccount: web3.PublicKey | web3.Keypair =
    response.tokenAccount;
  if ('createInstruction' in response) {
    ixSet.instructions.push(...response.createInstruction);
  }

  if (potentialToolkitTokenAccount instanceof web3.Keypair) {
    toolkitTokenAccount = potentialToolkitTokenAccount.publicKey;
    ixSet.signers.push(potentialToolkitTokenAccount);
  } else {
    toolkitTokenAccount = potentialToolkitTokenAccount;
  }

  const ix = await program.instruction.processWithdrawShips(
    stakingBump,
    scoreVarsBump,
    scoreVarsShipBump,
    escrowAuthBump,
    escrowBump,
    treasuryAuthBump,
    treasuryBump,
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        scoreVarsShipAccount: scoreVarsShipAccount,
        playerAtlasTokenAccount: playerAtlasTokenAccount,
        shipTokenAccountEscrow: shipEscrow,
        shipTokenAccountReturn: shipTokenAccount,
        toolkitTokenAccountSource: toolkitTokenAccount,
        treasuryTokenAccount: treasuryTokenAccount,
        treasuryAuthorityAccount: treasuryAuthorityAccount,
        escrowAuthority: escrowAuthority,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
        shipMint: shipMint,
        toolkitMint: toolkitMint,
      },
    },
  );
  ixSet.instructions.push(ix);
  return ixSet;
}

/**
 * Close all escrow accounts and ship staking accounts
 *
 * @param connection - web3.Connection object
 * @param playerPublicKey - Player's public key
 * @param shipMint - Ship mint address
 * @param fuelMint - Fuel mint address
 * @param foodMint - Food mint address
 * @param armsMint - Arms mint address
 * @param programId - Deployed program ID for the SCORE program
 */
export async function closeAccountsInstruction(
  connection: web3.Connection,
  playerPublicKey: web3.PublicKey,
  shipMint: web3.PublicKey,
  fuelMint: web3.PublicKey,
  foodMint: web3.PublicKey,
  armsMint: web3.PublicKey,
  programId: web3.PublicKey,
): Promise<web3.TransactionInstruction> {
  const [escrowAuthority, escrowAuthBump] = getScoreEscrowAuthAccount(
    programId,
    shipMint,
    playerPublicKey,
  );
  const [shipEscrow, shipBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    null,
    playerPublicKey,
  );
  const [fuelEscrow, fuelBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    fuelMint,
    playerPublicKey,
  );
  const [foodEscrow, foodBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    foodMint,
    playerPublicKey,
  );
  const [armsEscrow, armsBump] = getScoreEscrowAccount(
    programId,
    shipMint,
    armsMint,
    playerPublicKey,
  );
  const [scoreVarsAccount, scoreVarsBump] = getScoreVarsAccount(programId);
  const [shipStakingAccount, stakingBump] = getShipStakingAccount(
    programId,
    shipMint,
    playerPublicKey,
  );

  const idl = getScoreIDL(programId);
  const provider = new AnchorProvider(connection, null, null);
  const program = new Program(<Idl>idl, programId, provider);
  const ix = await program.instruction.processCloseAccounts(
    stakingBump,
    scoreVarsBump,
    shipBump,
    fuelBump,
    foodBump,
    armsBump,
    escrowAuthBump,
    {
      accounts: {
        playerAccount: playerPublicKey,
        shipStakingAccount: shipStakingAccount,
        scoreVarsAccount: scoreVarsAccount,
        shipTokenAccountEscrow: shipEscrow,
        fuelTokenAccountEscrow: fuelEscrow,
        foodTokenAccountEscrow: foodEscrow,
        armsTokenAccountEscrow: armsEscrow,
        escrowAuthority: escrowAuthority,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: web3.SystemProgram.programId,
        shipMint: shipMint,
        fuelMint: fuelMint,
        foodMint: foodMint,
        armsMint: armsMint,
        clock: web3.SYSVAR_CLOCK_PUBKEY,
      },
    },
  );
  return ix;
}
